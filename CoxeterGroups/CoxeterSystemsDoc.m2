document {
	Key => {bruhatCompare},
	
	Headline => "whether a Coxeter group element is less than another in Bruhat order",
	
	Usage => "bruhatCompare(w, v)",
	
	Inputs => {
		"w" => GroupElement,
		"v" => GroupElement => {"of the same Coxeter group as w"}
		},
	
	Outputs => {
		Boolean => {"whether the first group element is less than or equal to the 
		    second in Bruhat order"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The Bruhat order of a Coxeter group W is the partial order on its elements whose
	    covering relations are precisely the relations w < v where w = v*t for some reflection
	    t of W sand w has smaller length than v.  This function determines w <= v in the Bruhat
	    order for any two elements w and v of W by making use of the fact that w <= v if and
	    only if some reduced subword of v is equal to w."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"bruhatCompare(v*u, v*u*v)",
		"bruhatCompare(u*v*u*v, id_D)"
		},
	    
	PARA {"We note that it is not enough to simply check whether the normal form of w is a
	    subword of the normal form v."},
	    
	EXAMPLE {
	    	"M = matrix {{1, 2, 0}, {2, 1, 0}, {0, 0, 1}}", 
		"W = coxeterGroup({a,b,c}, M)", 
		"bruhatCompare(a*b, b*c*a)",
		"(b*c*a)*(a*c*a)" 
		},	    
	    
	PARA {"For permutations p and q in a symmetric group written in one-line notation as
	    p = p_0p_1...p_(n-1) and q = q_0q_1...q_(n-1), we have p <= q in Bruhat order if
	    and only if the Young tableaux of p and q obtained by sorting the initial strings
	    of lengths determined by the descent set of p have the property that the tableau 
	    of p is entrywise less than or equal to the tableau of q."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",
		"bruhatCompare(S_{3,0,2,1}, S_{3,2,1,0})",
		"d = descentSet S_{3,0,2,1}",  
		"tableau(S_{3,0,2,1}, d)",
		"tableau(S_{3,2,1,0}, d)",
		},
	    
	 SeeAlso => {bruhatInterval, bruhatPoset, reflections, tableau}
	    }
	
document {
	Key => {bruhatPoset},
	
	Headline => "construct the Bruhat poset of a finite Coxeter group",
	
	Usage => "bruhatPoset W",
	
	Inputs => {
		"W" => CoxeterGroup => {"a finite group"}
		},
	
	Outputs => {
		Poset => {"of elements of the group ordered by the Bruhat order"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The Bruhat order of a Coxeter group W is the partial order on its elements whose
	    covering relations are precisely the relations w < v where w = v*t for some reflection
	    t of W sand w has smaller length than v.  This function constructs the Bruhat poset
	    of W when W is a finite group."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"BPD = bruhatPoset D;",
		"digraph(BPD_*, adjacencyMatrix hasseDiagram BPD)",
		},
	    
	PARA {"Below is an example of the Bruhat poset of a symmetric group."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",
		"BPS = bruhatPoset S;",
		"digraph(BPS_*, adjacencyMatrix hasseDiagram BPS)",
		},
	    
	 SeeAlso => {bruhatCompare, bruhatInterval, reflections}
	    }	

document {
	Key => {cartanMatrix},
	
	Headline => "the Cartan matrix of a Coxeter group",
	
	Usage => "cartanMatrix W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		Matrix => {"the Cartan matrix of the Coxeter group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The Cartan matrix of a Coxeter group W is the symmetric matrix B representing the
	    bilinear form on the reflection representation of W.  The rows and columns of B are
	    indexed by the set S of Coxeter generators of W, and the entries of B are given by:"},
	    
        UL { "B_s_s = 1 for all s in S,", "B_s_t = -cos(pi/m_s_t) for all s =!= t in S with 
	    m_s_t > 0, and", "B_s_t = 0 for all s =!= t in S with m_s_t = 0,"},
	    
        PARA {"where m_s_t is the corresponding entry of the Coxeter matrix of W."}, 
	
	EXAMPLE {
	     	"S = symmetricGroup 5",
		"cartanMatrix S",
	        },
	
	PARA {"Since the Cartan matrix involves values of cosine at fractions of 2*pi, it can
	    represented with entries in an extension field of the rationals by an appropriate 
	    root of unity using the package ", TO Cyclotomic, ".  Specifically, we use the 
	    cyclotomic field generated by an n-th root of unity, where n is twice the least
	    common multiple of the positive entries in the Coxeter matrix of W."},
	
	EXAMPLE {
	     	"D = dihedralGroup 4",
		"B = cartanMatrix D",
		"ww_8 = (ring B)_0;",
		"B_1_0 == -(ww_8 + ww_8^7)/2"
	        },
	    	    
	 SeeAlso => {coxeterGroup, isCoxeterMatrix}
	    }

document {
	Key => {coxeterGroup},
	
	Headline => "construct a Coxeter group",
	
	Usage => "coxeterGroup(S, M) \n coxeterGroup M \n coxeterGroup(S, D) \n coxeterGroup D",
	
	Inputs => {
	    	"S" => List => {"of symbols for the generators of the group"},
		"M" => Matrix => {"the Coxeter matrix of the group"},
		"D" => DynkinDiagram,  
		Variable => String => {"used as the base symbol for indexing the generators of the group
		    when a list of symbols is not specified"},
		},
	
	Outputs => {
		CoxeterGroup
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is a finitely presented group determined a finite set of generators
	     S such that the only relations on the generators are of the form (s*t)^m = 1 for some 
	     non-negative integer m = M_s_t for all s, t in S, where:"}, 
	
	UL {"M_s_s = 1 for all s in S, and", "M_s_t =!= 1 for all s =!= t."}, 
	
	PARA {"The symmetric matrix M of these exponents having rows and columns indexed by the 
	    elements of S is called the Coxeter matrix of the Coxeter group.  This function constructs 
	    the Coxeter group corresponding to a given Coxeter matrix and list of generator symbols."},
	
	EXAMPLE {
	    "M = matrix {{1, 2, 0}, {2, 1, 0}, {0, 0, 1}}", 
	    "W = coxeterGroup({a,b,c}, M)",
	    "b*a" 
	    },

	PARA {"When a list of generator symbols is not specified, the generators of the Coxeter group
	    are represented by indexed variables.  The base symbol of the generators can be changed
	    as follows."},
	
	EXAMPLE {
	     "M = matrix {{1, 3, 2}, {3, 1, 3}, {2, 3, 1}}", 
	     "W = coxeterGroup(M, Variable => \"p\")",
	     "p_1*p_0*p_1" 
	     },
	 
	 PARA {"Equivalently, the data of the Coxeter matrix can be encoded into a Dynkin diagram."},
	
	EXAMPLE {
	     "D = dynkinDiagram(cycleGraph 4, {{0,1} => 4, {2, 3} => 5})", 
	     "W = coxeterGroup D",
	     "(s_0*s_1)^3*s_2*(s_1*s_3)^(-1)" 
	     },
	    
	 SeeAlso => {(coxeterGroup, Graph), dynkinDiagram, isCoxeterMatrix, specificDynkin, specificCoxeterGroup}
	    }	

document {
	Key => {(coxeterGroup, Graph)},
	
	Headline => "construct a right-angled Coxeter group",
	
	Usage => "coxeterGroup G",
	
	Inputs => {
		"G" => Graph
		},
	
	Outputs => {
		CoxeterGroup => {"a right-angled Coxeter group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is right-angled if every entry of its Coxeter matrix M is 
	    either 0, 1, or 2. For Coxeter generators s =!= t, the condition M_s_t = 2 
	    implies that s and t commute, and we interpret M_s_t = 0 as meaning there 
	    is no relation between s and t.  We note that this conflicts with the conventions 
	    of some authors who take M_s_t as infinity in that case.  This function constructs
	    a right-angled Coxeter group W corresponding to a graph G, where the generators of
	    W correspond bijectively with the vertices of G and two generators s and t commute
	    in W if and only if the corresponding vertices are not adjacent in G."}, 
	
	EXAMPLE {
	    "coxeterGroup pathGraph 5"
	    },

	PARA {"Graphs with only isolated vertices correspond to direct products of copies of ZZ/2."},
	
	EXAMPLE {
	    	"W = coxeterGroup complementGraph completeGraph 3",
		"groupOrder W"
		},
	    
	 SeeAlso => {coxeterGroup, isCoxeterMatrix, isRightAngled}
	    }	

document {
	Key => {coxeterMatrix},
	
	Headline => "get the Coxeter matrix of a Coxeter group",
	
	Usage => "coxeterMatrix W",
	
	Inputs => {
		"W" => CoxeterGroup  
		},
	
	Outputs => {
		Matrix => {"the corresponding Coxeter matrix"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is a finitely presented group determined a finite set of generators
	     S such that the only relations on the generators are of the form (s*t)^m = 1 for some 
	     non-negative integer m = M_s_t for all s, t in S, where:"}, 
	
	UL {"M_s_s = 1 for all s in S, and", "M_s_t =!= 1 for all s =!= t."}, 
	
	PARA {"The symmetric matrix M of these exponents having rows and columns indexed by the 
	    elements of S is called the Coxeter matrix of the Coxeter group.  This function returns
	    the Coxeter matrix associated to a given Coxeter group."},
	
	EXAMPLE {
	    "S = symmetricGroup 4",
	    "coxeterMatrix S"
	    },
	    
	 SeeAlso => {coxeterGroup, isCoxeterMatrix}
	    }

document {
	Key => {descentSet, [descentSet, Left], [descentSet, AllReflections]},
	
	Headline => "the list of descents of a Coxeter group element",
	
	Usage => "descentSet w",
	
	Inputs => {
		"w" => GroupElement,
		Left => Boolean => {"compute the left descents instead of right descents"},
		AllReflections => Boolean => {"compute descents using all reflections instead
		    of just the Coxeter generators"}
		},
	
	Outputs => {
		List => {"of indices of generators of the Coxeter group that are descents"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The right descent set of an element w in a Coxeter group W is the set of all
	    Coxeter generators s of W such that w*s has smaller length than w.  If W has a
	    set of generators S = {s_0,s_1,...,s_n}, this function returns the list of all
	    indices i such that s_i is a descent of w."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"descentSet(u*v*u*v)"
		},

	PARA {"The left descent set of element w is defined analogously as the set of all
	    Coxeter generators s of W such that s*w has smaller length than w.  It is equal
	    to the right descent set of w^(-1) and can be computed as follows."},
	    
	EXAMPLE {
		"descentSet(u*v, Left => true)"
		},

	PARA {"The descent set of element w with respect to all reflections is similarly 
	    as the set of all reflections t of W such that w*t has smaller length than w.  If 
	    T = {t_0,t_1,...,t_m} is the list of all reflections of W, this function returns 
	    the list of all indices i such that t_i is a descent of w."},
	    
	EXAMPLE {
	    	"reflections D",
		"descentSet(u*v*u*v, AllReflections => true)",
		"descentSet(u*v, Left => true, AllReflections => true)"
		},
	    
	PARA {"For a permutation in a symmetric group written in one line notation as
	    p = p_0p_1...p_(n-1), the descent set agrees with the usual descent set of p, 
	    consisting of all indices i such that p_i > p_(i+1)."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",  
		"descentSet S_{3,0,2,1}",
		"descentSet(S_{3,0,2,1}, Left => true)",
		"toList S_{3,0,2,1}^(-1)"
		},
	    
	 SeeAlso => {exchanges, reflections, (length, GroupElement)}
	    }	

document {
	Key => {dihedralGroup},
	
	Headline => "construct a dihedral group",
	
	Usage => "dihedralGroup n",
	
	Inputs => {
		"n" => ZZ => {"an integer greater or equal to 2"}
		},
	
	Outputs => {
		CoxeterGroup => {"the dihedral group of order 2*n"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The dihedral group of order 2*n is the group of symmetries of a regular
	    n-gon.  As a Coxeter group, the dihedral group of order 2*n is generated by 
	    two elements corresponding to reflections of the n-gon across one of its
	    angle bisectors and an adjacent edge bisector.  Dihedral groups are precisely
	    the Coxeter groups of type I in the classification of finite Coxeter groups."}, 
	
	EXAMPLE {
	    	"D = dihedralGroup 4",  
	    	"gens D",
		"(s^2, t^2)"
		},

	PARA {"Typically, the dihedral group is described as being generated by the reflection s
	    and an element r corresponding to the rotation of the n-gon by 2*pi/n radians.
	    Such a rotation can be obtained as the product of the Coxeter generators s and t."},

	EXAMPLE {
	    	"r = s*t",
		"apply(4, i -> r^(i+1) )"
		},
	    
	 SeeAlso => {coxeterGroup, specificCoxeterGroup}
	    }

document {
	Key => {exchanges},
	
	Headline => "the list of descents of a Coxeter group element",
	
	Usage => "exchanges(word, s) \n exchanges(w, s)",
	
	Inputs => {
	    	"word" => List => {"of generators of a Coxeter group"},
		"w" => GroupElement,
		"s" => GroupElement => {"a Coxeter generator of the group of the list or group element"}
		},
	
	Outputs => {
		List => {"of indices of generators of the Coxeter group that are descents"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Given a word w = s_0s_1...s_r in the generators of a Coxeter group W and a
	    generator s such that w*s has length less than w, there is an index i such that
	    omitting s_i from w is equal to w*s.  This function returns a list of all indices
	    i (possibly empty) such that removing s_i from w is equal to w*s."},
	    
	EXAMPLE {
	    	"S = symmetricGroup 4",
		"exchanges({s_1, s_2, s_1, s_0}, s_2)"
		},

	PARA {"When the first input is a group element instead of a list, normal form of the
	    group element is used for the word."},
	    
	EXAMPLE {
	        "w = s_2*s_0",
		"exchanges(w, s_2)"
		},
	    
	 SeeAlso => {descentSet, (length, GroupElement)}
	    }
	
document {
	Key => {group},
	
	Headline => "get the associated group of an object",
	
	Usage => "group w",
	
	Inputs => {
		"w" => GroupElement
		},
	
	Outputs => {
		CoxeterGroup => {"the group associated to the input object"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	EXAMPLE {
	    	"D = dihedralGroup 4", 
		"gens D", 
	    	"group s"
		},
	    
	 SeeAlso => {coxeterGroup}
	    }
	
document {
	Key => {groupElements, [groupElements, Format]},
	
	Headline => "the list of all elements of a finite Coxeter group",
	
	Usage => "groupElements W",
	
	Inputs => {
		"W" => CoxeterGroup => {"a finite group"},
		Format => String => {"allows changing the output format to a \"hashtable\""}
		},
	
	Outputs => {
		List => {"of all elements of the group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})", 
		"groupElements D"
		},
	    
	PARA {"By default, the function returns a list of all elements of the group.  However,
	    the elements may also be returned in the form of a hashtable partitioned by length
	    as follows."},

	EXAMPLE {
	    	"S = symmetricGroup 4", 
		"groupElements(S, Format => \"hashtable\")"
		},
	    
	 SeeAlso => {coxeterGroup, groupOrder, isFiniteGroup, (length, GroupElement)}
	    }
	
document {
	Key => {groupOrder, [groupOrder, DegreeLimit]},
	
	Headline => "the order of a group or group element",
	
	Usage => "groupOrder u \n groupOrder W",
	
	Inputs => {
	    	"u" => GroupElement,
		"W" => CoxeterGroup,
		DegreeLimit => ZZ => {"the maximum exponent to check whether the element has order less than or equal to"}
		},
	
	Outputs => {
		ZZ => {"the order of the group or group element"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	EXAMPLE {
	    	"groupOrder symmetricGroup 4",
	    	"D = dihedralGroup 4",
		"r = s*t", 
		"groupOrder r"
		},
	    
	 SeeAlso => {coxeterGroup, isFiniteGroup}
	    }			

document {
	Key => {hyperoctahedralGroup},
	
	Headline => "construct a finite signed symmetric group",
	
	Usage => "hyperoctahedralGroup n",
	
	Inputs => {
		"n" => ZZ => {"a positive integer"}
		},
	
	Outputs => {
		CoxeterGroup => {"the hyperoctahedral group on n letters"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The hyperoctahedral group on n letters is the group of all bijections p from the
	    set {-n, ..., -1, 0, 1, ..., n} to itself such that p(i) = -p(-i) for all i. As a 
	    Coxeter group, the hyperoctahedral group is generated by the simple transpositions 
	    s_i interchanging i + 1 and i + 2 and leaving all other elements fixed for 
	    i = 0, 1, ..., n-2, together with permutation s_(n-1) sending n to -n and leaving all
	    other elements fixed. Hyperoctahedral groups are precisely the Coxeter groups of 
	    type B in the classification of finite Coxeter groups."}, 
	
	EXAMPLE {
	    	"H = hyperoctahedralGroup 4",  
	    	"gens H",
		"p = s_0*s_3*s_1*s_2*s_3",
		},
	    
	 PARA {"Just like permutations in a symmetric group, permutations in the hyperoctahedral 
	     group are completely determined by their action on the elements 1, 2, ..., n, and so,
	     they can be represented in one-line notation. Permutations in the hyperoctahedral 
	     group can be converted to one-line notation using the command ", TO toList, "."},
	 
  
	 EXAMPLE {
		"toList p",
		},
	    
	 PARA {"Elements of the hyperoctahedral group can also be specified using one-line 
	     notation as follows."},
	     
	 EXAMPLE {
		"H_{2,3,-4,-1}",
		},  
	    
	 SeeAlso => {coxeterGroup, (toList, GroupElement), symmetricGroup, specificCoxeterGroup}
	    }	

document {
	Key => {isCoxeterMatrix},
	
	Headline => "whether an integer matrix is a Coxeter matrix",
	
	Usage => "isCoxeterMatrix M",
	
	Inputs => {
		"M" => Matrix => {"with non-negative integer entries"}
		},
	
	Outputs => {
		Boolean => {"whether the matrix is the Coxeter matrix of some Coxeter group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is determined a finite set of generators S such that the
	     only relations on the generators are of the form (s*t)^m = 1 for some non-negative
	     integer m = M_s_t for all s, t in S, where:"}, 
	
	UL {"M_s_s = 1 for all s in S, and", "M_s_t =!= 1 for all s =!= t."}, 
	
	PARA {"The symmetric matrix M of these 
	     exponents having rows and columns indexed by the elements of S is called the Coxeter
	     matrix of the Coxeter group.   This function checks whether a given matrix is the 
	     Coxeter matrix of a Coxeter group."},
	
	EXAMPLE {
	    	"M = matrix {{1, 2, 0}, {2, 1, 3}, {0, 3, 1}}",  
	    	"isCoxeterMatrix M",
		},

	PARA {"For Coxeter generators s =!= t, the condition M_s_t = 2 implies that s and t commute.
	    We will interpret M_s_t = 0 as meaning there is no relation between s and t.  We note that
	    this conflicts with the conventions of some authors who take M_s_t as infinity in that case."},
	    
	 SeeAlso => {coxeterGroup}
	    }
	
document {
	Key => {isRightAngled},
	
	Headline => "whether a Coxeter group is right-angled",
	
	Usage => "isRightAngled W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		Boolean => {"whether the Coxeter group is right-angled"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is right-angled if every entry of its Coxeter matrix M is 
	    either 0, 1, or 2. For Coxeter generators s =!= t, the condition M_s_t = 2 
	    implies that s and t commute, and we interpret M_s_t = 0 as meaning there 
	    is no relation between s and t.  We note that this conflicts with the conventions 
	    of some authors who take M_s_t as infinity in that case."}, 
	
	EXAMPLE {
	    "isRightAngled symmetricGroup 4"
	    },

	PARA {"When all of the Coxeter generators commute, we get the direct product of copies
	    of ZZ/2."},
	
	EXAMPLE {
	    	"m = matrix {{1, 2, 2}, {2, 1, 2}, {2, 2, 1}}",
	    	"W = coxeterGroup m",
		"groupOrder W"
		},
	    
	 SeeAlso => {coxeterGroup, (coxeterGroup, Graph), isCoxeterMatrix}
	    }	

document {
	Key => {isFiniteGroup},
	
	Headline => "whether a Coxeter group is a finite group",
	
	Usage => "isFiniteGroup W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		Boolean => {"whether the Coxeter group is finite"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"There is a complete classification of whether a Coxeter group is finite based on
	    the connected components of its associated Dynkin diagram.  In particular, the 
	    underlying graph of the Dynkin diagram of a finite Coxeter group must be acyclic."},
	    
	EXAMPLE {
	    	"D = dynkinDiagram cycleGraph 4",  
		"W = coxeterGroup D",
		"isFiniteGroup W"
		},
	    
	PARA {"Finite Coxeter groups include symmetric groups, hyperoctahedral groups, and
	    dihedral groups."},
	        
	EXAMPLE {
	    	"H = hyperoctahedralGroup 4",  
		"isFiniteGroup H"
		},

	PARA {"Here is a less straightforward example of a finite Coxeter group, constructed
	    as the direct product of groups of types \"D5\" and \"H4\"."},	    
	    
	EXAMPLE {
	    	"G = graph{{1,2},{2,4},{3,5},{3,8},{3,9},{4,6},{7,8}}",
		"w = {{4,6} => 5}",
		"D = dynkinDiagram(G, w)",
		"W = coxeterGroup D",  
		"isFiniteGroup W"
		},
	    
	 SeeAlso => {coxeterGroup, dynkinDiagram, specificDynkin, specificCoxeterGroup}
	    }

document {
	Key => {(length, GroupElement)},
	
	Headline => "the length of a Coxeter group element",
	
	Usage => "length w",
	
	Inputs => {
		"w" => GroupElement => {"an element of a Coxeter group"}
		},
	
	Outputs => {
		ZZ => {"the length of the group element"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Given a Coxeter group W with set of generators S, the length of a group element w
	    is the smallest number of factors in a word on the generators S whose product in W is
	    equal to w.  A word representing w of minimum length is said to be reduced.  Since all
	    group elements are automatically represented by a canonical reduced word in the 
	    generators, the length of w is just the number of factors in this reduced expression."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"r = u*v",
		"length(r^3)",
		"r^3"
		},
	    
	PARA {"For a permutation p in a symmetric group, the length of p is equal to the number of
	    inversions of p when written in one-line notation p = p_1p_2...p_n.  An inversion of p
	    is any pair of indices i < j such that p_i > p_j."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",  
		"p = s_0*s_2*s_1*s_2",
		"length p"
		},
	    
	PARA {"The one-line notation of the permutation p can be obtained as follows."},
	        
	EXAMPLE {
		"toList p"
		},
	    
	 SeeAlso => {coxeterGroup}
	    }

document {
	Key => {longWord},
	
	Headline => "the unique longest element of a finite Coxeter group",
	
	Usage => "longWord W",
	
	Inputs => {
		"W" => CoxeterGroup => {"a finite group"}
		},
	
	Outputs => {
		GroupElement => {"the longest element of the group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Every finite Coxeter group has a unique element of maximum length, which is also 
	    the unique maximum element of the group in the Bruhat order. This function returns 
	    that element."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"longWord D"
		},
	    
	PARA {"For a symmetric group on n letters {0,1,...,n-1}, the long word is the 
	    permutation whose one-line notation is (n-1)(n-2)...321."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",
		"w = longWord S",
		"toList w" 
		},
	    
	 SeeAlso => {isFiniteGroup, bruhatCompare, bruhatPoset}
	    }
	
document {
	Key => {nerveComplex},
	
	Headline => "construct the nerve complex of a Coxeter group",
	
	Usage => "nerveComplex W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		List => {"the list of all spherical subsets of the Coxeter generators"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"If W is a Coxeter group with set S of Coxeter generators, a subset T of S
	    is called spherical if the parabolic subgroup generated by T is a finite group.
	    The nerve complex of W is the simplicial complex of all spherical subsets of S."},
	    
	PARA {"If W happens to be a right-angled Coxeter group, then the spherical subsets
	    correspond bijectively with independent sets of vertices in the Dynkin diagram of W."},
	    
	EXAMPLE {
	    	"W = specificCoxeterGroup \"A'1\"",  
		"dynkinDiagram W",
		"nerveComplex W"
		},
	    
	 SeeAlso => {isFiniteGroup, subgroup, isRightAngled, independenceComplex}
	    }

document {
	Key => {reflectionRep},
	
	Headline => "the reflection representation of a Coxeter group",
	
	Usage => "reflectionRep W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		Function => {"the reflection representation of the Coxeter group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The reflection representation of a Coxeter group W with set of generators S is 
	    a linear action of W on a real vector space of dimension |S|.  The generators in S
	    act as reflections fixing a hyperplane pointwise and sending their corresponding
	    basis vector to it negative.  These reflections are orthogonal transformations with
	    respect to a certain symmetric bilinear form."},
	    
        PARA {"Given a Coxeter group W, this function returns the function that assigns to each
	    element of W a matrix representing its action in the reflection representation.  By
	    definition, these matrices involve values of cosine at fractions of 2*pi.  They are
	    represented with entries in an extension field of the rationals by an appropriate 
	    root of unity using the package ", TO Cyclotomic, "."}, 
	
	EXAMPLE {
	    	"S = symmetricGroup 4",  
	    	"rho = reflectionRep S;",
		"apply(gens S, s -> rho s)",
		"rho(s_0*s_2*s_1*s_2)"
		},
	    
	 PARA {"Below is the reflection representation for the dihedral group of order 8. We
	     highlight the action of the rotation r = s*t."},
	 
	EXAMPLE {
	     	"D = dihedralGroup 4",
		"rho = reflectionRep D;",
		"apply(gens D, u -> rho u)",
	        "r = s*t",
	        "apply(4, i -> rho(r^(i+1)) )"
	        },
	    
	 SeeAlso => {coxeterGroup, cartanMatrix}
	    }

document {
	Key => {reflections},
	
	Headline => "the list of all reflections of a Coxeter group",
	
	Usage => "reflections W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		List => {"of all reflections of the Coxeter group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Given a Coxeter group W with set of generators S, a reflection of W is any
	    element conjugate to an element s in S. The reflections of W are in one-to-one
	    correspondence with the set of positive roots in the reflection representation
	    of W."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",  
		"reflections D"
		},
	    
	PARA {"For a symmetric group, the reflections are precisely the transpositions."},
	        
	EXAMPLE {
	    	"S = symmetricGroup 4",
		"apply(reflections S, t -> toList t)"
		},
	    
	 Caveat => {"Not yet implemented for infinite Coxeter groups."},
	    
	 SeeAlso => {reflectionRep, (roots, CoxeterGroup)}
	    }

document {
	Key => {(relations, CoxeterGroup)},
	
	Headline => "the list of defining relations of a Coxeter group",
	
	Usage => "relations W",
	
	Inputs => {
		"W" => CoxeterGroup  
		},
	
	Outputs => {
		List => {"the list of defining relations of the group"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"A Coxeter group is a finitely presented group determined a finite set of generators
	     defined by relations of a certain form.  Given a Coxeter group W, this function
	     returns a list of lists of the Coxeter generators of W, where each list represents
	     a defining relation on the generators."}, 
	
	EXAMPLE {
	    "S = symmetricGroup 4",
	    "relations S"
	    },
	    
	 SeeAlso => {coxeterGroup, coxeterMatrix}
	    }
	
document {
	Key => {(roots, CoxeterGroup)},
	
	Headline => "the root system a Coxeter group",
	
	Usage => "roots W",
	
	Inputs => {
		"W" => CoxeterGroup
		},
	
	Outputs => {
		HashTable => {"of all positive and negative roots of the Coxeter group"},
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The reflection representation of a Coxeter group W with set of generators S is 
	    a linear action of W on a real vector space of dimension |S|.  The elements of the
	    orbits of the standard basis vectors under the action of W are called the roots of
	    W.  A root is called positive if all of its entries are non-negative and negative
	    if all of its entries are non-positive.  Every root is either positive or negative,
	    and the positive roots are in one-to-one correspondence with the reflection elements
	    of W."},
	    
	EXAMPLE {
	    	"D = dihedralGroup 4",  
		"roots D"
		},
	    
	 Caveat => {"Not yet implemented for infinite Coxeter groups."},
	    
	 SeeAlso => {reflectionRep, reflections,  (roots, GroupElement)}
	    }
	
document {
	Key => {(roots, GroupElement)},
	
	Headline => "the positive root associated to a reflection in a Coxeter group",
	
	Usage => "roots t",
	
	Inputs => {
		"t" => GroupElement => {"a reflection of a Coxeter group"}
		},
	
	Outputs => {
		Matrix => {"the positive root corresponding to the reflection"},
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The reflection representation of a Coxeter group W with set of generators S is 
	    a linear action of W on a real vector space of dimension |S|.  The elements of the
	    orbits of the standard basis vectors under the action of W are called the roots of
	    W.  A root is called positive if all of its entries are non-negative and negative
	    if all of its entries are non-positive.  Every root is either positive or negative,
	    and the positive roots are in one-to-one correspondence with the reflection elements
	    of W.  This function returns the positive root corresponding to a given reflection."},
	    
	EXAMPLE {
	    	"D = dihedralGroup(4, Variables => {\"u\", \"v\"})",
		"t = u*v*u",  
		"beta = roots t"
		},
	    
	PARA {"If t is a reflection of W, then t acts as a reflection in the reflection 
	    representation by sending the corresponding positive root to its negative and
	    fixing pointwise the hyperplane orthogonal to the root."},   

	EXAMPLE {
	    	"rho = reflectionRep D;",  
		"(rho t)*beta"
		},
	    
	 Caveat => {"Not yet implemented for infinite Coxeter groups."},
	    
	 SeeAlso => {reflectionRep, reflections, (roots, CoxeterGroup)}
	    }		
	
document {
	Key => {sign},
	
	Headline => "the sign of a Coxeter group element",
	
	Usage => "sign w",
	
	Inputs => {
		"w" => GroupElement => {"an element of a Coxeter group"}
		},
	
	Outputs => {
		ZZ => {"the sign of the group element"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Since every generator s of a Coxeter group W satisfies s^2 = 1, there is a unique
	    homomormorphism W -> {-1, 1}, called the sign homomorphism, that send each generator
	    to -1.  This function returns the sign of a given element of a Coxeter group."},
	    
	EXAMPLE {
	    	"S = symmetricGroup 4",  
		"sign(s_0*s_2*s_1*s_2)"
		},
	    
	 SeeAlso => {coxeterGroup}
	    }	


document {
	Key => {specificCoxeterGroup},
	
	Headline => "create a built-in Coxeter group",
	
	Usage => "specificCoxeterGroup t \n specificCoxeterGroup(S, t)",
	
	Inputs => {
	    	"S" => List => {"of generator symbols for the Coxeter group"},
	    	"t" => String => {"the name/Dynkin type of the Coxeter group"}
		},
	
	Outputs => {
		CoxeterGroup
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Returns one of the irreducible finite Coxeter groups as classified by their 
	    Dynkin diagrams.  This includes Coxeter groups of types A, B, D, E, F, H, and I."},
	    
	PARA {"There are infinite families of Dynkin diagrams of type \"An\", \"Bn\", \"Dn\", and
	    \"In\", where n is a non-negative integer that is at least 1, 2, 4, and 2 respectively."},
	
	EXAMPLE {
		"specificCoxeterGroup \"D5\"",
		},

	PARA {"There are also the exceptional Dynkin diagrams of type \"E6\", \"E7\", \"E8\", \"F4\",
	     \"H3\", and \"H4\".  The symbols for the Coxeter generators can be specified as follows."},
	     
 	EXAMPLE {
		"specificCoxeterGroup({a, b, c, d}, \"F4\")",
		},
	    
	 PARA {"The Coxeter groups of types A, B, and I are precisely symmetric groups, 
	     hyperoctahedral groups, and dihedral groups respectively."},   
	    
	 SeeAlso => {coxeterGroup, dynkinDiagram, specificDynkin, dihedralGroup, 
	     hyperoctahedralGroup, symmetricGroup}
	    }

document {
	Key => {specificDynkin},
	
	Headline => "create a built-in Dynkin diagram",
	
	Usage => "specificDynkin t",
	
	Inputs => {
	    	"t" => String => {"the name of the Dynkin diagram"}
		},
	
	Outputs => {
		DynkinDiagram
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"Returns one of the named Dynkin diagrams in the classification of finite Coxeter
	    groups.  This includes diagrams of types A, B, D, E, F, H, and I."},
	    
	PARA {"There are infinite families of Dynkin diagrams of type \"An\", \"Bn\", \"Dn\", and
	    \"In\", where n is a non-negative integer that is at least 1, 2, 4, and 2 respectively."},
	
	EXAMPLE {
	    	"specificDynkin \"A3\"",
		"specificDynkin \"B4\"",
		"specificDynkin \"D5\"",
		"specificDynkin \"I5\"",
		},

	PARA {"There are also the exceptional Dynkin diagrams of type \"E6\", \"E7\", \"E8\", \"F4\",
	     \"H3\", and \"H4\"."},
	     
	 	EXAMPLE {
	    	"specificDynkin \"E8\"",
		"specificDynkin \"F4\"",
		"specificDynkin \"H3\"",
		},
	    
	 SeeAlso => {coxeterGroup, dynkinDiagram, specificCoxeterGroup}
	    }
	
document {
	Key => {symmetricGroup},
	
	Headline => "construct a finite symmetric group",
	
	Usage => "symmetricGroup n",
	
	Inputs => {
		"n" => ZZ => {"a positive integer"}
		},
	
	Outputs => {
		CoxeterGroup => {"the symmetric group on n letters"}
		},
	
	PARA {"This function is provided by the package ", TO CoxeterGroups,"."},
	
	PARA {"The symmetric group on n letters is the group of all bijections from the
	    set {0, 1, ..., n - 1} to itself. As a Coxeter group, the symmetric group is 
	    generated by the simple transpositions s_i interchanging i and i + 1 for some i 
	    and leaving all other elements fixed.  Symmetric groups are precisely the Coxeter
	    groups of type A in the classification of finite Coxeter groups."}, 
	
	EXAMPLE {
	    	"S = symmetricGroup 4",  
	    	"gens S",
		"p = s_0*s_2*s_1*s_2",
		},
	    
	 PARA {"Permutations in the symmetric group can be converted to one-line notation using
	     the command ", TO toList, "."},
	     
	 EXAMPLE {
		"toList p",
		},
	    
	 PARA {"Elements of the symmetric group can also be specified using one-line notation as
	     follows."},
	     
	 EXAMPLE {
		"S_{1,3,2,0}",
		}, 
	    
	 SeeAlso => {coxeterGroup, (toList, GroupElement), specificCoxeterGroup}
	    }	
	
-*
document {
	Key => {idealGradedMoebiusAlgebra, 
	    (idealGradedMoebiusAlgebra, Matroid),
	    (idealGradedMoebiusAlgebra, Graph)
	    },
	
	Headline => "the defining ideal of the graded M\u00F6bius algebra of a matroid",
	
	Usage => "idealGradedMoebiusAlgebra M \n idealGradedMoebiusAlgebra G",
	
	Inputs => {
	    	"M" => Matroid,
	    	"G" => Graph,
		},
	
	Outputs => {
		Ideal => {"the defining ideal of the graded M\u00F6bius algebra of the matroid/graph"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"The graded M\u00F6bius algebra of a matroid M is the finite-dimensional algebra having
	    basis elements y_F in one-to-one correspondence with the flats F of M with multiplication
	    given by declaring y_F*y_G = y_H (where H is the join of F and G) if rk H = rk F + rk G, and
	    by setting y_F*y_G = 0 otherwise.  This function computes the defining ideal of a minimal
	    presentation for the graded M\u00F6bius algebra of the matroid M.  The generators of the ideal
	    include the squares of all the variables and certain binomials corresponding to circuits 
	    of the matroid.  By definition, the value of the  Hilbert function of the graded M\u00F6bius 
	    algebra in degree r records the number of flats of M of rank r."},   
	
	EXAMPLE {
		"M = uniformMatroid(4, 5);",
		"I = idealGradedMoebiusAlgebra M",
		"numerator hilbertSeries(I, Reduce => true)"
		},
	    
	PARA {"Given a graph G, the command idealGradedMoebiusAlgebra G can be used to compute
	    the definig ideal of the graded M\u00F6bius algebra of its cycle matroid."},    
	
	EXAMPLE {
	    	"G = completeGraph 4",
		"idealGradedMoebiusAlgebra G",
		},
	    
	PARA {"The graded M\u00F6bius algebra of a matroid M can also be identified as a special subalgebra of
	    the augmented Chow ring of M.  In the standard presentation of the augmented Chow ring of M with
	    augmented variables y_i, the graded M\u00F6bius algebra is the subalgebra generated by the y_i."},
	    
	SeeAlso => {idealAugmentedChowRing}
	    }

document {
	Key => {isCChordal, (isCChordal, Matroid)},
	
	Headline => "whether a matroid is C-chordal",
	
	Usage => "isCChordal M",
	
	Inputs => {
	    	"M" => Matroid,
		},
	
	Outputs => {
		Boolean => {"whether the matroid is C-chordal"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A matroid M is C-chordal if for every circuit C of size at least 4 in M there are circuits
	    A and B whose intersection consists of a single element and whose symmetric difference is C."},
	    
	PARA {"For the cycle matroid of a graph G, the matroid being C-chordal is equivalent to the graph 
	    being chordal."},    
	
	EXAMPLE {
	    	"isCChordal matroid completeGraph 5",
		},
	    
	PARA {"The following checks whether two non-graphic matroids are C-chordal."},    
	
	EXAMPLE {
	    	"isCChordal specificMatroid \"fano\"",
		"isCChordal dual matroid completeGraph 5",
		},
	    
	 SeeAlso => {}
	    }


document {
	Key => {isSimpleVertex, (isSimpleVertex, Graph, Thing)},
	
	Headline => "whether a vertex of a graph is a simple vertex",
	
	Usage => "isSimpleVertex(G, v)",
	
	Inputs => {
	    	"G" => Graph,
	    	"v" => Thing => {"a vertex of the graph"},
		},
	
	Outputs => {
		Boolean => {"whether the vertex is a simple vertex"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"The closed neighborhood of a vertex v in a graph G is the set of all neighbors
	    of v together with v.  The vertex v is simple if the distinct sets of closed 
	    neighborhoods of vertices in the closed neighborhood of v are totally ordered by
	    inclusion."},
	    
	PARA {"Every vertex of a complete graph is simple."},    
	
	EXAMPLE {
	    	"G = completeGraph 5",
		"all(vertexSet G, v -> isSimpleVertex(G, v) )",
		},
	    
	PARA {"On the other hand, no vertex of a sun graph is simple."},    
	
	EXAMPLE {
	    	"G = sunGraph 4",
		"any(vertexSet G, v -> isSimpleVertex(G, v) )",
		},
	    
	SeeAlso => {isStronglyChordal}
	    }

document {
	Key => {isStrongElimOrder, (isStrongElimOrder, Graph, List)},
	
	Headline => "whether a list of vertices is a strong elimination order",
	
	Usage => "isStrongElimOrder(G, V)",
	
	Inputs => {
	    	"G" => Graph,
		"V" => List => {"a permuted list of the vertices of the graph"}
		},
	
	Outputs => {
		Boolean => {"whether the given ordering of vertices is a strong elimination
		    order"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"An ordering v_1,...,v_n of the vertices of a graph G is a strong elimination order if
	    for each i and for any neighbors v_k and v_l of v_i in the induced subgraph G_i = G[v_i,...,v_n]
	    with k < l, the closed neighbordhood of v_k in G_i is contained in the closed neighborhood
	    of v_l in G_i.  This function checks whether a given ordering of the vertices of a graph
	    is a strong elimination order.  Graphs having a strong elimination order are called strongly
	    chordal."},
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"isStronglyChordal B",
		"isStrongElimOrder(B, {0, 1, 2, 3, 4, 5, 6})",
		"isStrongElimOrder(B, {4, 6, 5, 0, 3, 1, 2})",
		},
	    
	 SeeAlso => {isStronglyChordal, strongElimOrder}
	    }
	
document {
	Key => {isStronglyChordal, (isStronglyChordal, Graph)},
	
	Headline => "whether a graph is strongly chordal",
	
	Usage => "isStronglyChordal G",
	
	Inputs => {
	    	"G" => Graph,
		},
	
	Outputs => {
		Boolean => {"whether the graph is strongly chordal"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A graph G is strongly chordal if it is chordal and every cycle C of even
	    length in G has a chord whose ends are an odd distance apart in C.  Equivalently,
	    G is strongly chordal if and only if it is chordal and every induced subgraph of
	    G has a simple vertex. As a result, there is always a (not necessarily unique) 
	    ordering v_1,...,v_n of the vertices of a strongly chordal graph in which 
	    v_i is a simple vertex for the subgraph induced by v_1,...,v_{i-1} for each i.
	    In practice, this function decides whether a graph is strongly chordal by 
	    determining whether it is possible to construct such an ordering."},   
	
	EXAMPLE {
		"G = graph {{a, b}, {a, c}, {b, c}, {b, d}, {b, e}, {c, d}, {c, e}, {d, e}}",
		"isStronglyChordal G",
		},
	    
	PARA {"Yet another characterization of strongly chordal graphs is that they are 
	    precisely the chordal graphs that do not contain a sun graph as an induced
	    subgraph."},    
	
	EXAMPLE {
	    	"G = sunGraph 4",
		"isChordal G",
		"isStronglyChordal G",
		},
	    
	SeeAlso => {isSimpleVertex}
	    }

document {
	Key => {isStronglyTChordal, (isStronglyTChordal, Matroid, List)},
	
	Headline => "whether a matroid is strongly T-chordal for a given ordering of its ground set",
	
	Usage => "isStronglyTChordal(M, E)",
	
	Inputs => {
	    	"M" => Matroid,
		"E" => List => {"a permuted list of elements of the ground set of the matroid,
		    arranged from smallest to largest"}
		},
	
	Outputs => {
		Boolean => {"whether the matroid is strongly T-chordal for the given ordering of its ground set"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A strong elimination order for a matroid M is an ordering of the elements of its ground set
	    such that for each circuit C of size at least 4 in M and each i in C different from the smallest
	    element of C in the given ordering, there is a 3-circuit T such that T - C has size 1 and the
	    smallest element of T in the given ordering is contained in C.  If a matroid has a strong elimination
	    order, it is called strongly T-chordal.  This function checks whether a given ordering of the 
	    ground set of a matroid is a strong elimination order."}, 
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"M = matroid B",
		"hashTable apply(#(M.groundSet), i -> i => M.cache.groundSet#i)",
		"isStronglyTChordal(M, {3, 6, 7, 9, 10, 11, 2, 1, 5, 0, 4, 8})",
		},
	    
	 SeeAlso => {isCChordal}
	    }

document {
	Key => {nbcBases, (nbcBases, Matroid, List)},
	
	Headline => "the maximal nbc-sets of a matroid",
	
	Usage => "nbcBases(M, E)",
	
	Inputs => {
	    	"M" => Matroid,
		"E" => List => {"a permuted list of elements of the ground set of the matroid,
		    arranged from smallest to largest"}
		},
	
	Outputs => {
		List => {"the inclusion-maximal nbc-sets of the matroid with
		    respect to the given order"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"Given an ordering of the ground set of a matroid M, a broken circuit of M is a set of
	    the form C - {min C}, where C is a circuit of M and min C denotes the smallest element of
	    C in the given ordering.  A subset of the ground set of M is called an nbc-set if it contains
	    no broken circuits.  The inclusion-maximal nbc-sets are particular bases of M, called nbc-bases."},
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 3, 5)",
		"M = matroid B",
		"nbcBases(M, toList(0..6))",
		},
	    
	 SeeAlso => {brokenCircuitComplex}
	    }

document {
	Key => {strongElimOrder, (strongElimOrder, Graph)},
	
	Headline => "find a strong elimination order of a strongly chordal graph",
	
	Usage => "strongElimOrder G",
	
	Inputs => {
	    	"G" => Graph,
		},
	
	Outputs => {
		List => {"an ordering of vertices that is a strong elimination order"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"This produces an ordering of the vertices of a strongly chordal graph that
	    is a strong elimination order. See ", TO isStrongElimOrder, " and ", TO isStronglyChordal,
	    " for more information about strong elimination orders and strongly chordal graphs."},
	
	EXAMPLE {
	    	"B = deleteVertex(sunGraph 4, 7)",
		"V = strongElimOrder B",
		"isStrongElimOrder(B, V)",
		},
	    
	 SeeAlso => {isStrongElimOrder, isStronglyChordal}
	    }

document {
	Key => {sunGraph, (sunGraph, ZZ)},
	
	Headline => "construct a sun graph",
	
	Usage => "sunGraph n",
	
	Inputs => {
	    	"n" => ZZ => {"greater than 2"},
		},
	
	Outputs => {
		Graph => {"the n-sun graph"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A n-sun graph, also sometimes called an n-trampoline, is the graph on 2n
	    vertices v_1,...,v_n, w_1,...,w_n in which the v_i form a complete graph and
	    w_i is adjacent to only v_i and v_{i+1} for i < n and w_n is adjacent to only
	    v_n and v_1."},   
	
	EXAMPLE {
		"G = sunGraph 4"
		},
	    
	SeeAlso => {isStronglyChordal}
	    }
	
document {
	Key => {(thresholdGraph, ZZ, List)},
	
	Headline => "construct a threshold graph by specifying dominating vertices",
	
	Usage => "thresholdGraph(n, D)",
	
	Inputs => {
	    	"n" => ZZ => {"a positive integer"},
		"I" => List => {"a list of positive integers in {1,...,n}"},
		},
	
	Outputs => {
		Graph => {"the threshold graph"}
		},
	
	PARA {"This function is provided by the package ", TO LatticeChowRings,"."},
	
	PARA {"A threshold graph is a graph that is constructed by starting with an isolated 
	    vertex and iteratively adding another isolated vertex or a vertex that adjacent to 
	    each vertex added before it (a dominating vertex). This function produces a threshold
	    graph with vertices {0,1,...,n} whose dominating vertices are precisely the elements 
	    of the list {0,1,...,n} - I."},   
	
	EXAMPLE {
		"G = thesholdGraph(9, {5,8})"
		},
	    
	PARA {"The maximal cliques of G are precisely the closed neighborhods N[i] for i in I or i = 0.  
	    For example, the maximal cliques of the above graph are:"},
	
	EXAMPLE {
		"apply(facets cliqueComplex G, m -> positions(first exponents m, e -> e == 1))"
		}, 
	    
	SeeAlso => {isStronglyChordal}
	    }	
 
*-
